<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Estado del despegue — Autoajustable (robusto)</title>
<style>
  html,body{height:100%;margin:0;padding:0;overflow:hidden;background:#0f1720;font-family:Inter,Arial,Helvetica,sans-serif;color:#fff}
  *{box-sizing:border-box}
  .viewport{width:100%;height:100vh;display:flex;align-items:center;justify-content:center;padding:12px;overflow:hidden}
  .base{width:900px;height:620px;display:flex;align-items:center;justify-content:center}
  .card{width:95%;height:92%;border-radius:18px;padding:22px;display:flex;flex-direction:column;align-items:center;gap:12px;background:rgba(255,255,255,0.03);box-shadow:0 10px 40px rgba(0,0,0,0.4);overflow:hidden}
  .title{text-align:center}
  .title .main{font-size:26px;font-weight:900;text-transform:uppercase}
  .title .sub{font-size:18px;font-weight:900;opacity:0.75;margin-top:6px;text-transform:uppercase}
  .badge{width:100%;height:56%;border-radius:16px;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:12px;text-align:center;font-weight:900;transition:all .42s;overflow:hidden}
  .mainText{font-size:56px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .subText{margin-top:10px;font-size:18px;font-weight:800}
  .meta{margin-top:10px;font-size:13px;color:#cbd5e1;opacity:0.95}
  .open{background:linear-gradient(180deg,#06d6a0,#028a5f);color:#01210f}
  .closed{background:linear-gradient(180deg,#ff5b5b,#9b0e0e);color:#fff}
  .unknown{background:linear-gradient(180deg,#9aa0a6,#6f757a);color:#0f1011}
  .pop{animation:pop .52s cubic-bezier(.2,.9,.3,1) both}
  @keyframes pop{0%{transform:scale(.92);opacity:0}60%{transform:scale(1.03);opacity:1}100%{transform:scale(1)}}
  @media (prefers-reduced-motion:reduce){.pop{animation:none!important}}
  /* Debug overlay (hidden by default) */
  #debug { position: fixed; left: 8px; bottom: 8px; z-index:9999; background: rgba(0,0,0,0.6); color:#fff; font-size:12px; padding:8px 10px; border-radius:8px; max-width:40%; display:none; }
  #debug pre{ margin:0; white-space:pre-wrap; word-break:break-word; max-height:200px; overflow:auto }
</style>
</head>
<body>
  <div class="viewport">
    <div id="baseWrap" class="base">
      <div class="card">
        <div class="title">
          <div class="main"><strong>ESTADO DEL DESPEGUE:</strong></div>
          <div class="sub"><strong>TAKEOFF STATUS:</strong></div>
        </div>

        <div id="badge" class="badge unknown pop" role="status" aria-live="polite">
          <span id="mainText" class="mainText">CARGANDO…</span>
          <span id="subText" class="subText"></span>
        </div>

        <div id="meta" class="meta">Última actualización: —</div>
      </div>
    </div>
  </div>

  <!-- Debug pequeño (actívalo si necesitas más info visual) -->
  <div id="debug"><strong>DEBUG</strong><pre id="debugPre"></pre></div>

<script>
/* ------------------ CONFIG ------------------ */
const SHEET_ID = "1ZJ4mVkXZyUVBRXLeiSHI2gSOt7JdcYj92bfKtPujU3g"; // tu hoja
const GID = 0;
const POLL_INTERVAL_MS = 10000;
const FULL_RELOAD_MS = 15000;

/* DOM refs */
const baseWrap = document.getElementById('baseWrap');
const badge = document.getElementById('badge');
const mainText = document.getElementById('mainText');
const subText = document.getElementById('subText');
const meta = document.getElementById('meta');
const debug = document.getElementById('debug');
const debugPre = document.getElementById('debugPre');

/* ========== fit to viewport (simple scale) ========== */
const BASE_W = 900, BASE_H = 620;
function fit(){
  const w = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
  const h = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
  const scale = Math.min(w / BASE_W, h / BASE_H, 1);
  baseWrap.style.transform = `scale(${scale})`;
  baseWrap.style.transformOrigin = 'center center';
}
window.addEventListener('resize', fit);
window.addEventListener('orientationchange', ()=>setTimeout(fit,200));
fit();

/* ========== HELPERS UI ========== */
function showDebug(msg){
  debug.style.display = 'block';
  const now = new Date().toLocaleTimeString();
  debugPre.textContent = `${now} - ${msg}\n` + debugPre.textContent;
  console.debug(msg);
}
function hideDebug(){ debug.style.display = 'none'; }

function setStatusText(state, small){
  mainText.textContent = state;
  subText.textContent = small || '';
  meta.textContent = 'Última actualización: ' + new Date().toLocaleString();
}
function applyVisualState(text){
  const up = (text||'').toUpperCase().trim();
  badge.classList.remove('open','closed','unknown','pop');
  void badge.offsetWidth;
  if(up.includes('ABIER') || up.includes('OPEN')){
    badge.classList.add('open','pop');
    setStatusText('ABIERTO','OPEN');
  } else if(up.includes('CERR') || up.includes('CLOSED')){
    badge.classList.add('closed','pop');
    setStatusText('CERRADO','CLOSED');
  } else {
    badge.classList.add('unknown','pop');
    setStatusText(text || 'DESCONOCIDO','');
  }
}

/* ========== CSV fetch (método preferido) ========== */
async function fetchCsvFirst(){
  // endpoint CSV de Google Sheets para hoja publicada/compartida
  const url = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/export?format=csv&gid=${GID}`;
  console.debug('Trying CSV URL ->', url);
  const res = await fetch(url, {cache:'no-store'});
  if(!res.ok) throw new Error('CSV HTTP ' + res.status);
  const csv = await res.text();
  // parse minimal: primera celda de la primera línea
  const lines = csv.split(/\r?\n/).filter(Boolean);
  if(lines.length === 0) throw new Error('CSV vacío');
  // Si hay encabezados o celdas, tomar la primera columna de la primera línea
  const firstLine = lines[0];
  const cols = firstLine.split(',');
  const cell = cols[0] ? cols[0].trim() : '';
  console.debug('CSV parsed cell:', cell);
  return cell;
}

/* ========== GVIZ fetch (fallback robusto) ========== */
async function fetchGvizFallback(){
  const url = `https://docs.google.com/spreadsheets/d/${SHEET_ID}/gviz/tq?gid=${GID}&tqx=out:json`;
  console.debug('Trying GViz URL ->', url);
  const res = await fetch(url, {cache:'no-store'});
  if(!res.ok) throw new Error('GViz HTTP ' + res.status);
  const text = await res.text();

  // intentar extraer google.visualization.Query.setResponse(...)
  let m = text.match(/google\.visualization\.Query\.setResponse\(([\s\S]*?)\);?/);
  let jsonText = null;

  if(m && m[1]){
    const frag = m[1];
    const start = frag.indexOf('{');
    if(start === -1) throw new Error('gviz: no { inside setResponse');
    let depth = 0, end = -1;
    for(let i = start; i < frag.length; i++){
      if(frag[i] === '{') depth++;
      else if(frag[i] === '}'){
        depth--;
        if(depth === 0){ end = i; break; }
      }
    }
    if(end === -1) throw new Error('gviz: braces not balanced inside setResponse');
    jsonText = frag.slice(start, end + 1);
  } else {
    const start = text.indexOf('{');
    if(start === -1) throw new Error('gviz: no { in response');
    let depth = 0, end = -1;
    for(let i = start; i < text.length; i++){
      if(text[i] === '{') depth++;
      else if(text[i] === '}'){
        depth--;
        if(depth === 0){ end = i; break; }
      }
    }
    if(end === -1) throw new Error('gviz: braces not balanced global');
    jsonText = text.slice(start, end + 1);
  }

  let json;
  try { json = JSON.parse(jsonText); } catch(e){ console.error('GViz JSON.parse failed', e); throw new Error('gviz json parse error'); }
  const rows = (json.table && json.table.rows) ? json.table.rows : [];
  if(rows.length === 0) throw new Error('gviz: no rows');
  const first = rows[0].c && rows[0].c[0] && rows[0].c[0].v ? String(rows[0].c[0].v).trim() : '';
  console.debug('GViz parsed cell:', first);
  return first;
}

/* ========== MAIN: try CSV first, then GViz fallback ========== */
async function readState(){
  // Primero CSV
  try {
    const csvVal = await fetchCsvFirst();
    if(csvVal && csvVal.length > 0){
      console.info('readState: got CSV value ->', csvVal);
      return csvVal;
    }
    // si CSV vacío, probar GViz
  } catch (e) {
    console.warn('CSV fetch failed, will try GViz. Reason:', e && e.message ? e.message : e);
    showDebug('CSV fail: ' + (e.message || e));
  }

  // Fallback GViz
  try {
    const gv = await fetchGvizFallback();
    console.info('readState: got GViz value ->', gv);
    return gv;
  } catch (e2) {
    console.error('GViz fallback failed:', e2);
    showDebug('GViz fail: ' + (e2.message || e2));
    throw e2;
  }
}

/* ========== update loop ========== */
async function updateOnce(){
  try {
    const val = await readState();
    if(!val) throw new Error('empty value');
    applyVisualState(val);
    hideDebug(); // todo ok
  } catch(err){
    console.error('updateOnce error', err);
    showDebug('updateOnce error: ' + (err.message || err));
    badge.classList.remove('open','closed');
    badge.classList.add('unknown');
    setStatusText('Error al obtener datos','');
  }
}

/* start */
updateOnce();
setInterval(updateOnce, POLL_INTERVAL_MS);
setInterval(()=>{ try{ location.reload(true); } catch(e){ location.reload(); } }, FULL_RELOAD_MS);

</script>
</body>
</html>
